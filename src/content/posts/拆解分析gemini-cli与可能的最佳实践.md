---
title: 拆解分析Gemini-CLI与可能的最佳实践
publishDate: 2025-06-27 17:21:00
---
关于 Gemini-CLI，这两天也很火，从我开始用的2k到32k star。

根据项目结构与一些实现细节，我先进行一些详细全面的认识，以此指导与该“终端Agent”的协作实践。从结构出发，而非体验，更多的是基于代码结构与文档。

我的感受：相较于coding agent，即只将其用作代码修改或功能开发，终端类Agent有很大的开发空间。

- - -

### 总览

总的来说，这是一个前后端分离的项目。不同于frontend与backend的名称，使用的是：

cli-命令行界面：
- 包括输入、回复、工具调用展示。通过渲染的React组件实现类似于web应用的体验。继承终端命令特色，可以通过上下键来回顾之前的文本输入。
- 能够解析普通文本输入，或/、@、！的特殊命令，前者直接发给交互的Gemini模型，后者则会经过后端（下文core）先解析。

![](/uploads/屏幕截图-2025-06-27-174115.png)

core-逻辑引擎：
- 与大模型交互。一个专门客户端（Client），在经过身份认证、构造请求与prompt与Gemini进行通信。
- prompt的构建（提示工程）。在前端输入的提示，包括文本或者特殊命令，均不会直接发给模型。二是先经过这里的处理，将最新的输入、对话历史、工具描述（用途和参数）组合再发送。
- 工具调用。模型决定使用工具（此时已将prompt发给模型并返回），其会按照格式输出工具参数。core中的工具编排层（`tool-registry.ts`）会解析这一参数：查找工具、判断格式是否准确、如果工具使用有风险（修改代码等）会向用户确认。批准后执行工具。
- 

### 工具

### 命令

### 记忆

### 其他

### 扩展
